{"meta":{"title":"Focal LAB","subtitle":"Having nothing to do, but CODING","description":"热衷于搞些技术尝鲜","author":"帅呆了的馒头君","url":"http://focalab.com"},"pages":[{"title":"categories","date":"2018-02-05T03:59:10.000Z","updated":"2018-02-05T03:59:32.981Z","comments":true,"path":"categories/index.html","permalink":"http://focalab.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-02-05T03:57:04.000Z","updated":"2018-02-05T03:57:26.009Z","comments":true,"path":"tags/index.html","permalink":"http://focalab.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Intellij IDEA自定义代码模板","slug":"intellij-live-template","date":"2018-02-17T06:01:40.000Z","updated":"2018-02-17T09:17:54.385Z","comments":true,"path":"2018/02/17/intellij-live-template/","link":"","permalink":"http://focalab.com/2018/02/17/intellij-live-template/","excerpt":"","text":"相信Java码农们大多都有过反复敲写这段代码的心酸经历： 123public static void main(String[] args) &#123; System.out.println(\"Hello World\");&#125; 不过，这种糟心的状况在各位接触IDE工具以后得到了较好改善。的确现在只需输入psvm、sout等提示性关键字，再按下TAB键，便能在短短几秒内自动生成上述代码段。是不是觉得黑科技感十足？接下来，就一起探寻下 Live Template 是如何影响程序狗的日常工作哒。 初识神器首先打开菜单 File -&gt; Settings，然后找到 Editor 目录下的 Live Template 子项，便可找到psvm、sout等关键字的代码模板定义。是不是发现也没想象中的那么神秘 ⊙▂⊙ 任意点选其中一项，不难注意到以下几个关键信息： Abbreviation表示模板缩略关键字（或称“缩写”），与psvm、sout作用等同 Description用于编写对该项模板的详细描述内容，方便日后检索识别 Template text用于编写代码模板 实例挑战由于IDEA将缩写词log默认定义为如下形式： 1private static final Logger logger = Logger.getLogger($CLASS$.class) 如果直接使用它，IDE通常会尝试导入标准库java.util.logging中的Logger类。但在大多数应用场景下，Slf4j+Logback这类框架组合还是要更为流行一些。这时如果再沿用这段代码模板，将让努力变成徒劳。那么问题就来了，如何对模板进行改造才好使呢？ 预定义变量代码模板中使用到的预定义变量（以美元符号夹在中间的形式表现出来），都不是凭空创造出来的，而是在下图所示的地方自行定义滴： 其中， Name代表模板变量名称，例如：这里定义为CLASS_NAME Expression代表模板变量与之对应的取值表达式，例如：通过className()获取当前文件的完整类名 Default value代表模板变量的默认值，它会在取值表达式为空时生效 动态模板紧接着引用上述的$CLASS_NAME$模板变量，根据实际采用的日志框架可将模板内容修改为： Slf4j 1private final static org.slf4j.Logger LOGGER = org.slf4j.LoggerFactory.getLogger($CLASS_NAME$.class); Log4j 1private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger($CLASS_NAME$.class); 至此，自定义代码模板的操作方法阐述完毕，赶紧亲自动手尝试下吧！ 参考文章 Generate log line with Intellij and live templates Stack OverFlow: Intellij Live Template","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://focalab.com/tags/Java/"},{"name":"Intellij IDEA","slug":"Intellij-IDEA","permalink":"http://focalab.com/tags/Intellij-IDEA/"},{"name":"Live Template","slug":"Live-Template","permalink":"http://focalab.com/tags/Live-Template/"}]},{"title":"MapStruct进阶踩坑指南","slug":"mapstruct-intro","date":"2018-02-12T05:06:36.000Z","updated":"2018-02-17T06:03:34.995Z","comments":true,"path":"2018/02/12/mapstruct-intro/","link":"","permalink":"http://focalab.com/2018/02/12/mapstruct-intro/","excerpt":"","text":"虽然CGLIB等基于运行时代码生成（Byte Code Generation at Runtime）的解决方案相比BeanUtils此类反射系框架具有显著的性能优势，但在某些应用场景下（比如：使用Converter进行定制转换时），还是不能忽视它与手动拷贝（Getter/Setter方法）之间的性能差距。 近期出炉的一份评测报告显示，MapStruct因采用了编译时生成代码（Compile-Time Code Generator）的特殊策略，最终获得了近乎媲美手动拷贝的跑分结果，是CGLIB BeanXXX工具包的理想升级/替代品。 依赖安装 由于MapStruct官方安装指导坑到无底线，所以根据实战经验重新整理了一波安装步骤，避免大家再次掉进去。 首先，务必在编译生命周期内引入Mapstruct Processor，以保证@Mapper、@Mapping等注解能被正确识别、处理： 123456789101112131415161718&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 然后，根据实际需求设置JDK版本、并正确引入对应依赖包： JDK1.8+（强烈推荐） 123456789101112131415161718&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- or higher, depending on your project --&gt; &lt;org.mapstruct.version&gt;1.2.0.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;...&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; JDK1.6/JDK1.7 123456789101112131415161718&lt;properties&gt; &lt;java.version&gt;1.6&lt;/java.version&gt; &lt;!-- Sepecify JDK Version, depending on your project --&gt; &lt;org.mapstruct.version&gt;1.2.0.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;...&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基本用法准备PayOrderEntity和LoanApplyDto两个测试类，确保两者均生成了字段对应的Getter、Setter方法，否则会导致拷贝失败。 依赖注入123@Mapper(componentModel = \"spring\")public interface TradeInfoMapper &#123;&#125; 123456789101112131415161718@RunWith(SpringRunner.class)@SpringBootTestpublic class TradeInfoMapperTest &#123; @Autowired private TradeInfoDefaultMapper tradeInfoMapper; @Test public void componentModel() throws Exception &#123; PayOrderEntity source = new PayOrderEntity(); source.setOrderNo(\"PAY20170810120512\"); source.setPayAmount(new BigDecimal(\"300.00\")); source.setReduceAmount(new BigDecimal(\"10.00\")); LoanApplyDto target = tradeInfoDefaultMapper.tradeInfoTrans(source); System.out.println(target); &#125;&#125; 参考文章 MapStruct Reference Guide MapStruct Examples MapStruct IDE插件汇总","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://focalab.com/tags/Java/"},{"name":"Bean","slug":"Bean","permalink":"http://focalab.com/tags/Bean/"},{"name":"Maven","slug":"Maven","permalink":"http://focalab.com/tags/Maven/"},{"name":"Gradle","slug":"Gradle","permalink":"http://focalab.com/tags/Gradle/"}]},{"title":"CGLIB BeanCopier实现高效拷贝的方法总结","slug":"cglib-beancopier","date":"2018-01-30T12:00:00.000Z","updated":"2018-02-17T06:03:01.959Z","comments":true,"path":"2018/01/30/cglib-beancopier/","link":"","permalink":"http://focalab.com/2018/01/30/cglib-beancopier/","excerpt":"","text":"CGLIB（Byte Code Generation Library）作为一个强大的Java代码生成工具库，实现了对ASM字节码工具的封装与操作简化，可在运行期动态扩展类和实现接口。 由于业务系统分层设计的缘故，经常会遇到PO/BO/VO/DTO等领域对象之间的相互转换，实现各层模型间的信息交换。根据有关博文的评测结果，CGLIB BeanCopier在多数应用场景下具有明显优于DozerMapper、Apache BeanUtils等工具的转换性能，因此决心对其功能点探索一波。 基本功能BeanCopier对象实例化方法如下： 1BeanCopier copier = BeanCopier.create(Class source, Class target, boolean useConverter); 其中，第三个参数useConverter表示是否引入Converter方式进行转换。 如果useConverter等于false，仅对属性名和类型完全相同的两种变量进行拷贝，不能针对某几个属性单独拷贝 如果useConverter等于true，可对某些特定属性值进行定制化转换，比如：四舍五入等操作 下面针对以上两种模式分别举例说明用法： Converter关闭模式准备PayOrderEntity和LoanApplyDto两个测试类，确保两者均生成了字段对应的Getter、Setter方法，否则会导致拷贝失败。 首先将PayOrderEntity实例化成源对象，并对各字段赋值： 1234PayOrderEntity source = new PayOrderEntity();source.setOrderNo(\"PAY20170810120512\");source.setPayAmount(new BigDecimal(\"300.00\"));source.setReduceAmount(new BigDecimal(\"10.00\")); 然后，将LoanApplyDto实例化成目标对象，保持各字段值初始为空： 1LoanApplyDto target = new LoanApplyDto(); 最后，利用BeanCopier进行字段拷贝： 12final BeanCopier copier = BeanCopier.create(PayOrderEntity.class, LoanApplyDto.class, false);copier.copy(source, target, null); 执行结果： 字段名 源对象 目标对象 字段类型 orderNo PAY20170810120512 PAY20170810120512 同属性名、同类型 payAmount 300.00 300.00 同属性名、同类型 reduceAmount 10.00 null 同属性名、不同类型 remark - null 不同属性名、不同类型 不难看出，对于源/目标对象对于同名、同类型字段可以实现正确拷贝，而不满足此条件的字段则无法进行相互拷贝。 Converter开启模式通过实现Converter接口，可利用此自定义转换器实现源/目标对象的定制化属性值转换： 12345package net.sf.cglib.core; public interface Converter &#123; Object convert(Object value, Class target, Object context); &#125; 其中，value表示源对象属性值，target表示目标对象属性类，context表示目标对象setter方法名。 具体转换样例如下： 1234567891011final BeanCopier copier = BeanCopier.create(PayOrderEntity.class, LoanApplyDto.class, true);copier.copy(source, target, new Converter() &#123; @Override public Object convert(Object value, Class target, Object context) &#123; if (value instanceof BigDecimal &amp;&amp; target.isAssignableFrom(String.class)) &#123; return value.toString(); &#125; else &#123; return value; &#125; &#125;&#125;); 执行结果： 字段名 源对象 目标对象 字段类型 orderNo PAY20170810120512 PAY20170810120512 同属性名、同类型 payAmount 300.00 300.00 同属性名、同类型 reduceAmount 10.00 10.00 同属性名、不同类型 remark - null 不同属性名、不同类型 不难看出，reduceAmount字段已经成功从源对象中拷贝到了目标对象，即便两个对象中定义的属性类型并不相同。 一旦使用Converter，BeanCopier只使用Converter定义的规则去拷贝属性，因此convert方法中要考虑所有属性的转换逻辑。 扩展功能CGLIB工具包为了更灵活地满足需求，还提供了BulkBean和BeanMap实现单个属性的定制化拷贝，而非BeanCopier那般把所有属性拷贝一遍。 12BulkBean bulkBean = BulkBean.create(Class target, String[] getters, String[] setters, Class[] types);BeanMap beanMap = BeanMap.create(Object bean); Bulk BeanBulkBean将整个拷贝动作拆分为getPropertyValues、setPropertyValues两个方法，使得Bean的取值/修改更加灵活可定制。这里依然引入PayOrderEntity作为样例： 123PayOrderEntity source = new PayOrderEntity();source.setOrderNo(\"PAY20170810120512\");source.setPayAmount(new BigDecimal(\"300.00\")); 利用BulkBean定义测试类中哪些字段可被操作、以及映射关系。例如，PayOrderEntity中允许 12345final String[] getters = new String[] &#123;\"getOrderNo\", \"getPayAmount\"&#125;;final String[] setters = new String[] &#123;\"setOrderNo\", \"setPayAmount\"&#125;;final Class[] clazzs = new Class[] &#123;String.class, BigDecimal.class&#125;;final BulkBean bulkBean = BulkBean.create(PayOrderEntity.class, getters, setters, clazzs); 调用source对象中orderNo和payAmount字段的Getter方法，输出结果分别为[PAY20170810120512, 300.00]： 1Object[] result = bulkBean.getPropertyValues(source); 调用source对象中orderNo和payAmount字段的Setter方法： 1bulkBean.setPropertyValues(bean, new Object[] &#123;\"CREDIT20180810121\", new BigDecimal(\"150.00\")&#125;); 执行结果： 字段名 源对象 目标对象 orderNo PAY20170810120512 CREDIT20180810121 payAmount 300.00 150.00 reduceAmount 10.00 10.00 Bulk Map业务系统经常会碰到POJO转换Map对象的应用场景，比如：报文加签/验签，这时需要用到BeanMap工具类来实现。这里依然引入PayOrderEntity作为样例： 123PayOrderEntity source = new PayOrderEntity();source.setOrderNo(\"PAY20170810120512\");source.setPayAmount(new BigDecimal(\"300.00\")); 然后构建映射对象： 1BeanMap beanMap = BeanMap.create(source); 此时，beanMap就是期望生成的Map对象，可使用beanMap.get(&quot;orderNo&quot;)获取orderNo字段属性值。 参考文章 CGLIB Tutorial 关于BeanCopier的一些思考 CGLIB中BeanCopier源码实现 cglib BeanCopier使用","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://focalab.com/tags/Java/"},{"name":"Bean","slug":"Bean","permalink":"http://focalab.com/tags/Bean/"},{"name":"ASM","slug":"ASM","permalink":"http://focalab.com/tags/ASM/"}]}]}