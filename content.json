{"meta":{"title":"Focal LAB","subtitle":"Focus on your potential instead of your limitations","description":"热衷于搞些技术尝鲜","author":"帅呆了的馒头君","url":"http://focalab.com"},"pages":[{"title":"about","date":"2018-02-22T04:37:56.000Z","updated":"2018-02-26T13:01:53.304Z","comments":true,"path":"about/index.html","permalink":"http://focalab.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-02-05T03:59:10.000Z","updated":"2018-02-26T13:01:53.194Z","comments":false,"path":"categories/index.html","permalink":"http://focalab.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-02-05T03:57:04.000Z","updated":"2018-02-26T13:01:53.676Z","comments":false,"path":"tags/index.html","permalink":"http://focalab.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Boot多环境配置资源装载方案","slug":"spring-boot-env-profile","date":"2018-02-23T13:39:42.000Z","updated":"2018-02-26T13:01:53.155Z","comments":true,"path":"2018/02/23/spring-boot-env-profile/","link":"","permalink":"http://focalab.com/2018/02/23/spring-boot-env-profile/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"http://focalab.com/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://focalab.com/tags/Spring-Boot/"},{"name":"Profile","slug":"Profile","permalink":"http://focalab.com/tags/Profile/"},{"name":"YAML","slug":"YAML","permalink":"http://focalab.com/tags/YAML/"}]},{"title":"Intellij IDEA自定义代码模板","slug":"intellij-live-template","date":"2018-02-17T06:01:40.000Z","updated":"2018-02-26T13:01:53.033Z","comments":true,"path":"2018/02/17/intellij-live-template/","link":"","permalink":"http://focalab.com/2018/02/17/intellij-live-template/","excerpt":"","text":"相信Java码农们大多都有过反复敲写这段代码的心酸经历： 123public static void main(String[] args) &#123; System.out.println(\"Hello World\");&#125; 不过，这种糟心的状况在各位接触IDE工具以后得到了较好改善。的确现在只需输入psvm、sout等提示性关键字，再按下TAB键，便能在短短几秒内自动生成上述代码段。是不是觉得黑科技感十足？接下来，就一起探寻下 Live Template 是如何影响程序狗的日常工作哒。 初识神器首先打开菜单 File -&gt; Settings，然后找到 Editor 目录下的 Live Template 子项，便可找到psvm、sout等关键字的代码模板定义。是不是发现也没想象中的那么神秘 ⊙▂⊙ 任意点选其中一项，不难注意到以下几个关键信息： Abbreviation表示模板缩略关键字（或称“缩写”），与psvm、sout作用等同 Description用于编写对该项模板的详细描述内容，方便日后检索识别 Template text用于编写代码模板 实例挑战由于IDEA将缩写词log默认定义为如下形式： 1private static final Logger logger = Logger.getLogger($CLASS$.class) 如果直接使用它，IDE通常会尝试导入标准库java.util.logging中的Logger类。但在大多数应用场景下，Slf4j+Logback这类框架组合还是要更为流行一些。这时如果再沿用这段代码模板，将让努力变成徒劳。那么问题就来了，如何对模板进行改造才好使呢？ 预定义变量代码模板中使用到的预定义变量（以美元符号夹在中间的形式表现出来），都不是凭空创造出来的，而是在下图所示的地方自行定义滴： 其中， Name代表模板变量名称，例如：这里定义为CLASS_NAME Expression代表模板变量与之对应的取值表达式，例如：通过className()获取当前文件的完整类名 Default value代表模板变量的默认值，它会在取值表达式为空时生效 动态模板紧接着引用上述的$CLASS_NAME$模板变量，根据实际采用的日志框架可将模板内容修改为： Slf4j 1private final static org.slf4j.Logger LOGGER = org.slf4j.LoggerFactory.getLogger($CLASS_NAME$.class); Log4j 1private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger($CLASS_NAME$.class); 至此，自定义代码模板的操作方法阐述完毕，赶紧亲自动手尝试下吧！ 参考文章 Generate log line with Intellij and live templates Stack OverFlow: Intellij Live Template","categories":[{"name":"Misc","slug":"Misc","permalink":"http://focalab.com/categories/Misc/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://focalab.com/tags/Java/"},{"name":"Intellij IDEA","slug":"Intellij-IDEA","permalink":"http://focalab.com/tags/Intellij-IDEA/"},{"name":"Live Template","slug":"Live-Template","permalink":"http://focalab.com/tags/Live-Template/"},{"name":"SLF4J","slug":"SLF4J","permalink":"http://focalab.com/tags/SLF4J/"},{"name":"Logger","slug":"Logger","permalink":"http://focalab.com/tags/Logger/"}]},{"title":"MapStruct进阶踩坑指南","slug":"mapstruct-intro","date":"2018-02-12T05:06:36.000Z","updated":"2018-02-26T13:01:53.098Z","comments":true,"path":"2018/02/12/mapstruct-intro/","link":"","permalink":"http://focalab.com/2018/02/12/mapstruct-intro/","excerpt":"","text":"虽然CGLIB等基于运行时代码生成的解决方案相比Apache BeanUtils等反射类框架具有明显的性能优势，但在某些应用场景下，比如：利用Converter接口实现定制化Bean转换，还是与Getter/Setter的手工拷贝形式存在性能差距。 A. Rey近期做过的一份O2O Mapping框架评测报告显示，MapStruct由于采用了编译时生成代码（Compile-Time Code Generator）的处理方案，使其最终获得了媲美纯手工拷贝的性能得分。而它注解式的编码风格、以及强大的IDE外围插件支持，让博主有了兴趣尝试一番。 依赖安装 由于MapStruct官方安装指导坑到无底线，所以根据实战经验重新整理了一波安装步骤，避免大家再次掉进去。 首先，务必在编译生命周期内引入Mapstruct Processor，以保证@Mapper、@Mapping等注解能被正确识别、处理： 123456789101112131415161718&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 然后，根据实际情况选择引入JDK版本对应的依赖包： JDK1.8+（强烈推荐） 123456789101112131415161718&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- or higher, depending on your project --&gt; &lt;org.mapstruct.version&gt;1.2.0.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;...&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; JDK1.6/JDK1.7 123456789101112131415161718&lt;properties&gt; &lt;java.version&gt;1.6&lt;/java.version&gt; &lt;!-- Sepecify JDK Version, depending on your project --&gt; &lt;org.mapstruct.version&gt;1.2.0.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;...&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 同名字段的自动映射 准备PayOrderEntity和LoanApplyDto两个测试类，确保两者均生成了字段对应的Getter、Setter方法，否则会导致拷贝失败。 编写带有@Mapper注解的一个映射接口和对应抽象方法，标记转换关系是由PayOrderEntity映射到LoanApplyDto的。这里要特别注意，MyBatis中也存在@Mapper同名注解，导入包路径时不要搞错了！ 12345678910import org.mapstruct.Mapper;@Mapperpublic interface TradeInfoMapper &#123; TradeInfoMapper INSTANCE = Mappers.getMapper(TradeInfoMapper.class); // Mapping JavaBean: PayOrderEntity --&gt; LoanApplyDto LoanApplyDto tradeInfoTrans(PayOrderEntity payOrderEntity);&#125; Mapstruct Processor能够在编译阶段实现这类接口，自动对同名字段适用恰当的（隐式）转换关系。这样，便可在调用方引用接口中声明的（静态）成员变量INSTANCE和tradeInfoTrans方法实施转换，例如： 123456PayOrderEntity source = new PayOrderEntity();source.setOrderNo(\"PAY20170810120512\");source.setPayAmount(new BigDecimal(\"300.00\"));source.setReduceAmount(new BigDecimal(\"10.00\"));LoanApplyDto target = TradeInfoDefaultMapper.INSTANCE.tradeInfoTrans(source); 执行结果： 字段名 源对象 目标对象 字段类型 orderNo PAY20170810120512 PAY20170810120512 同名字段，显式转换 payAmount 300.00 300.00 同名字段，显式转换 reduceAmount 10.00 10.00 同名字段，隐式转换 remark - null 非同名字段，不转换 定制转换方法MapStruct具备非常强大的同名字段映射能力，能够较为合理地处理不同类型间的转换诉求。与此同时，它针对非同名字段转换、字段值修改等个性化诉求也提供了一套定制手段。 非同名字段映射转换接上节，假设我们不使用自动映射、而采用手工指定的策略时，可以引入@Mappings或@Mapping注解来指定源/目标字段的具体映射关系： 单个字段123456789101112import org.mapstruct.Mapper;import org.mapstruct.Mapping;import org.mapstruct.Mappings;@Mapperpublic interface TradeInfoMapper &#123; TradeInfoMapper INSTANCE = Mappers.getMapper(TradeInfoMapper.class); @Mapping(source = \"orderNo\", target = \"remark\") LoanApplyDto tradeInfoTrans(PayOrderEntity payOrderEntity);&#125; 预期结果： 字段名 源对象 目标对象 字段类型 orderNo PAY20170810120512 PAY20170810120512 同名字段，显式转换 payAmount 300.00 300.00 同名字段，显式转换 reduceAmount 10.00 10.00 同名字段，隐式转换 remark - PAY20170810120512 指定映射关系 多个字段123456789101112131415import org.mapstruct.Mapper;import org.mapstruct.Mapping;import org.mapstruct.Mappings;@Mapperpublic interface TradeInfoMapper &#123; TradeInfoMapper INSTANCE = Mappers.getMapper(TradeInfoMapper.class); @Mappings(&#123; @Mapping(source = \"reduceAmount\", target = \"payAmount\"), @Mapping(source = \"payAmount\", target = \"reduceAmount\") &#125;) LoanApplyDto tradeInfoTrans(PayOrderEntity payOrderEntity);&#125; 预期结果： 字段名 源对象 目标对象 字段类型 orderNo PAY20170810120512 PAY20170810120512 同名字段，显式转换 payAmount 300.00 10.00 同名字段，但指定映射关系 reduceAmount 10.00 300.00 同名字段，但指定映射关系 remark - null 非同名字段，且未指定映射关系 特殊逻辑定制如果要实现字段转换中的一些特殊逻辑，比如：折扣金额（reduceAmount）要根据下单金额（payAmount）的0.1倍计算而来，就要用到默认方法（Java8+）、或抽象类方法来实现。具体可参考官方手册：增加定制方法章节，这里就不再赘述。 Mapper实例获取前面我们都是从getMapper()方法获取的Mapper实例，虽然具备单例、线程安全等诸多优点，但还是与Spring Framework、CDI这类依赖注入框架的使用习惯相背离。因此，MapStruct现在也加强了对它们的支持力度。例如： 123456@Mapper(componentModel = \"spring\")public interface TradeInfoMapper &#123; // Mapping JavaBean: PayOrderEntity --&gt; LoanApplyDto LoanApplyDto tradeInfoTrans(PayOrderEntity payOrderEntity);&#125; 便省去了声明INSTANCE成员变量的相关语句，仅仅依靠@Resource、@Autowired、@Inject这类JSR规范注解就能被加载到。当然前提是依赖注入框架支持这类注解使用。 1234567891011121314151617@RunWith(SpringRunner.class)@SpringBootTestpublic class TradeInfoMapperTest &#123; @Autowired private TradeInfoMapper tradeInfoMapper; @Test public void componentModel() throws Exception &#123; PayOrderEntity source = new PayOrderEntity(); source.setOrderNo(\"PAY20170810120512\"); source.setPayAmount(new BigDecimal(\"300.00\")); source.setReduceAmount(new BigDecimal(\"10.00\")); LoanApplyDto target = tradeInfoMapper.tradeInfoTrans(source); &#125;&#125; 参考文章 MapStruct Reference Guide MapStruct Examples","categories":[{"name":"Java","slug":"Java","permalink":"http://focalab.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://focalab.com/tags/Java/"},{"name":"Bean","slug":"Bean","permalink":"http://focalab.com/tags/Bean/"},{"name":"Maven","slug":"Maven","permalink":"http://focalab.com/tags/Maven/"},{"name":"Gradle","slug":"Gradle","permalink":"http://focalab.com/tags/Gradle/"}]},{"title":"CGLIB BeanCopier实现高效拷贝的方法总结","slug":"cglib-beancopier","date":"2018-01-30T12:00:00.000Z","updated":"2018-02-26T13:01:52.911Z","comments":true,"path":"2018/01/30/cglib-beancopier/","link":"","permalink":"http://focalab.com/2018/01/30/cglib-beancopier/","excerpt":"","text":"CGLIB（Byte Code Generation Library）作为一个强大的Java代码生成工具库，实现了对ASM字节码工具的封装与操作简化，可在运行期动态扩展类和实现接口。 由于业务系统分层设计的缘故，经常会遇到PO/BO/VO/DTO等领域对象之间的相互转换，实现各层模型间的信息交换。根据有关博文的评测结果，CGLIB BeanCopier在多数应用场景下具有明显优于DozerMapper、Apache BeanUtils等工具的转换性能，因此决心对其功能点探索一波。 基本功能BeanCopier对象实例化方法如下： 1BeanCopier copier = BeanCopier.create(Class source, Class target, boolean useConverter); 其中，第三个参数useConverter表示是否引入Converter方式进行转换。 如果useConverter等于false，仅对属性名和类型完全相同的两种变量进行拷贝，不能针对某几个属性单独拷贝 如果useConverter等于true，可对某些特定属性值进行定制化转换，比如：四舍五入等操作 下面针对以上两种模式分别举例说明用法： Converter关闭模式 准备PayOrderEntity和LoanApplyDto两个测试类，确保两者均生成了字段对应的Getter、Setter方法，否则会导致拷贝失败。 首先，将PayOrderEntity实例化成源对象、并对各字段赋值： 1234PayOrderEntity source = new PayOrderEntity();source.setOrderNo(\"PAY20170810120512\");source.setPayAmount(new BigDecimal(\"300.00\"));source.setReduceAmount(new BigDecimal(\"10.00\")); 然后，将LoanApplyDto实例化成目标对象，保持各字段值初始为空： 1LoanApplyDto target = new LoanApplyDto(); 最后，利用BeanCopier进行字段拷贝： 12final BeanCopier copier = BeanCopier.create(PayOrderEntity.class, LoanApplyDto.class, false);copier.copy(source, target, null); 执行结果： 字段名 源对象 目标对象 字段类型 orderNo PAY20170810120512 PAY20170810120512 同属性名、同类型 payAmount 300.00 300.00 同属性名、同类型 reduceAmount 10.00 null 同属性名、不同类型 remark - null 不同属性名、不同类型 不难看出，对于源/目标对象对于同名、同类型字段可以实现正确拷贝，而不满足此条件的字段则无法进行相互拷贝。 Converter开启模式通过实现Converter接口，可利用此自定义转换器实现源/目标对象的定制化属性值转换： 12345package net.sf.cglib.core; public interface Converter &#123; Object convert(Object value, Class target, Object context); &#125; 其中，value表示源对象属性值，target表示目标对象属性类，context表示目标对象setter方法名。 具体转换样例如下： 1234567891011final BeanCopier copier = BeanCopier.create(PayOrderEntity.class, LoanApplyDto.class, true);copier.copy(source, target, new Converter() &#123; @Override public Object convert(Object value, Class target, Object context) &#123; if (value instanceof BigDecimal &amp;&amp; target.isAssignableFrom(String.class)) &#123; return value.toString(); &#125; else &#123; return value; &#125; &#125;&#125;); 执行结果： 字段名 源对象 目标对象 字段类型 orderNo PAY20170810120512 PAY20170810120512 同属性名、同类型 payAmount 300.00 300.00 同属性名、同类型 reduceAmount 10.00 10.00 同属性名、不同类型 remark - null 不同属性名、不同类型 不难看出，reduceAmount字段已经成功从源对象中拷贝到了目标对象，即便两个对象中定义的属性类型并不相同。 一旦使用Converter，BeanCopier只使用Converter定义的规则去拷贝属性，因此convert方法中要考虑所有属性的转换逻辑。 扩展功能CGLIB工具包为了更灵活地满足需求，还提供了BulkBean和BeanMap实现单个属性的定制化拷贝，而非BeanCopier那般把所有属性拷贝一遍。 12BulkBean bulkBean = BulkBean.create(Class target, String[] getters, String[] setters, Class[] types);BeanMap beanMap = BeanMap.create(Object bean); Bulk BeanBulkBean将整个拷贝动作拆分为getPropertyValues、setPropertyValues两个方法，使得Bean的取值/修改更加灵活可定制。这里依然引入PayOrderEntity作为样例： 123PayOrderEntity source = new PayOrderEntity();source.setOrderNo(\"PAY20170810120512\");source.setPayAmount(new BigDecimal(\"300.00\")); 利用BulkBean定义测试类中哪些字段可被操作、以及映射关系。例如，PayOrderEntity中允许 12345final String[] getters = new String[] &#123;\"getOrderNo\", \"getPayAmount\"&#125;;final String[] setters = new String[] &#123;\"setOrderNo\", \"setPayAmount\"&#125;;final Class[] clazzs = new Class[] &#123;String.class, BigDecimal.class&#125;;final BulkBean bulkBean = BulkBean.create(PayOrderEntity.class, getters, setters, clazzs); 调用source对象中orderNo和payAmount字段的Getter方法，输出结果分别为[PAY20170810120512, 300.00]： 1Object[] result = bulkBean.getPropertyValues(source); 调用source对象中orderNo和payAmount字段的Setter方法： 1bulkBean.setPropertyValues(bean, new Object[] &#123;\"CREDIT20180810121\", new BigDecimal(\"150.00\")&#125;); 执行结果： 字段名 源对象 目标对象 orderNo PAY20170810120512 CREDIT20180810121 payAmount 300.00 150.00 reduceAmount 10.00 10.00 Bulk Map业务系统经常会碰到POJO转换Map对象的应用场景，比如：报文加签/验签，这时需要用到BeanMap工具类来实现。这里依然引入PayOrderEntity作为样例： 123PayOrderEntity source = new PayOrderEntity();source.setOrderNo(\"PAY20170810120512\");source.setPayAmount(new BigDecimal(\"300.00\")); 然后构建映射对象： 1BeanMap beanMap = BeanMap.create(source); 此时，beanMap就是期望生成的Map对象，可使用beanMap.get(&quot;orderNo&quot;)获取orderNo字段属性值。 参考文章 CGLIB Tutorial 关于BeanCopier的一些思考 CGLIB中BeanCopier源码实现 cglib BeanCopier使用","categories":[{"name":"Java","slug":"Java","permalink":"http://focalab.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://focalab.com/tags/Java/"},{"name":"Bean","slug":"Bean","permalink":"http://focalab.com/tags/Bean/"},{"name":"ASM","slug":"ASM","permalink":"http://focalab.com/tags/ASM/"}]}]}